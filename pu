#!/usr/bin/env bash
#_______________________________________________________________________________
#
# © 2016 Konstantin Gredeskoul
# Project Pullulant™
# https://github.com/kigster/pullulant/
#
# Distributed under MIT License
#_______________________________________________________________________________
#

function setup {
  export original_dir=$(pwd)
  export pu_home="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

  cd ${pu_home}
  source "lib/pu-loader"

}

setup

function package-config {
  pu-long-header
  declare -a features=(default ${opts_features})
  printf "\n\n"
  for feature in "${features[@]}"; do
    printf "   ${txtwht}${bldblu}Loading package definitions from feature ${txtblk}${bakylw} ◀︎ ${feature} ▶︎ ${txtrst}  \n"
    # if the feature has slashes, assume complete pathname
    local feature_with_path=$(echo $feature | grep  '/')
    if [ "${feature_with_path}" != "${feature}" ]; then
      package_file="${pu_home}/features/${feature}/packages"
    else
      package_file="$feature"
    fi
    if [ -s "${package_file}" ]; then
      source ${package_file}
    else
      printf "${bldred}ERROR: Unable to find feature ${feature}: ${bldwht}${package_file} does not exist?${txtrst}\n\n" >&2
      abort 131
    fi
  done

  source "${pu_home}/lib/pu-uniq-packages"

  if [ -t 0 ]; then stty -echo -icanon -icrnl time 0 min 0; fi
  keypress=''

  printf "\n${txtwht}   ${undylw}Attention:${txtrst} Please review the run parameters above.\n   If something is wrong or missing, hit Ctrl-C to abort.\n"
  for wait in {20..1}; do
    keypress="`cat -v`"
    printf "\033[1000D   You have ${bldylw}${wait}${txtrst} seconds until start. ${bldgrn}Press ANY key to continue.${txtrst}"
    sleep 1
    keypress="`cat -v`"
    if [ "x$keypress" != "x" ]; then
      break
    fi
    echo
  done
  if [ -t 0 ]; then stty sane; fi
  clear
}

opts_features=""

while getopts "ar:SBPLIRKFCfqnvlhHxpZt:" opt; do
  case $opt in
    a)
    export runners=${installers}          ;;
    r)
    [[ "${OPTARG}" == "sudo-enable"  ]] && export skip_sudo_disable=true
    [[ "${OPTARG}" == "sudo-disable" ]] && export sudoers_enabled=true
    if [ -z "$runners" ]; then
      export runners="$OPTARG"
    else
      export runners="$runners $OPTARG"
    fi                                    ;;

    #========================= Features     =========================

    t)
      export opts_features+=" $OPTARG "     ;;
    #========================= Runner Stuff =========================

    S)
      export opts_skip_sprout_wrap=yes      ;;
    B)
      export opts_skip_brew_upgrade=yes     ;;
    f)
      export opts_force=" --force "         ;;
    I)
      export opts_ignore_errors=yes         ;;
    P)
      export opts_rsync_backup=             ;;

    #========================= Home Brew ============================

    F)
      export opts_brew_formulae_only=yes    ;;
    C)
      export opts_brew_casks_only=yes       ;;
    L)
      export opts_brew_link_only=yes        ;;
    R)
      export opts_brew_reinstall=yes        ;;
    K)
      export opts_brew_link_force=yes       ;;

    #========================= Other          =======================

    Z)
      export opts_change_shell_to_zsh=yes     ;;

    #========================= Output Control =======================
    p)
      export opts_suppress_headers=yes      ;;
    q)
      export opts_quiet=yes                 ;;
    n)
      export opts_dryrun=yes                ;;
    v)
      export opts_verbose=" -v ";           ;;

    #========================= Help and Info ========================

    x)
      ./$0 -H | iconv -c -t ascii | sed "s,\x1B\[[0-9;]*[a-zA-Z],,g" > doc/help
      cat doc/help; finish;                 ;;
    h)
      pu-welcome-screen-short
      pu-print-help
      finish;                               ;;
    H)
      pu-welcome-screen-short
      pu-print-help
      pu-print-detailed-usage
      finish;                               ;;

    l)
      pu-short-header
      pu-installers-helpers
      finish;                               ;;
    \?)
      pu-print-help
      printf "${bakred}ERROR: $* is an invalid option :( ${txtrst}\n" >&2
      abort 126
      ;;
    :)
      printf "${bakred}ERROR: option -$opt requires an argument ${txtrst}\n" >&2
      abort 127
    ;;
  esac
done

function main {

  # Load package definitions based on the <-t template> setting.
  package-config

  # loop over installers, and if either passed as an argument or no arguments
  #" at all – run it."

  # By now we should have $runners set to either the whole set of installers
  # or to something specific passed via the flag. It should not be blank.
  [[ -z "${runners}" ]] || on_start

  local runners_started=0
  local runners_ignored=0
  local runners_completed=0

  export commands_failed=0
  export commands_completed=0
  export commands_ignored=0

  for runner in $runners; do
    # my arrays start with a 1
    export runners_started=$((runners_started + 1))

    [[ $runners_started -eq 1 ]] && pu-short-header

    # I so much rather prefer dashes in the function and file names than underscores.
    # Dashes just feel like a continuation. Underscores are from another era. Jurassic.
    pu-print-section-header ${runner}

    export status=
    eval ${runner}
    status=${status:-1}

    if [ ${status:-1} -ne 0 ]; then
      printf "${bldred}Non-zero status ${status} from '${runner}' runner :( ...\n${txtrst}"
      [[ ${opts_ignore_errors} ]] || abort $status
      export runners_ignored=$((runners_ignored + 1))
    fi

    runners_completed=$(($runners_completed + 1))
  done

  printf "\n"
  [[ ${runners_completed} -gt 0 ]]  && printf "${bldwht}%5d${bldgrn} runners succeeded\n" $runners_completed
  [[ ${runners_ignored} -gt 0 ]]    && printf "${bldwht}%5d${bldylw} runners failed, but were ignored\n"  $runners_ignored
  sep
  [[ ${commands_completed} -gt 0 ]] && printf "${bldwht}%5d${bldgrn} commands ran successfully\n" $commands_completed
  [[ ${commands_ignored} -gt 0 ]]   && printf "${bldwht}%5d${bldylw} commands had non-zero exit status, but were ignored\n" $runners_ignored
  [[ ${commands_failed} -gt 0 ]]    && printf "${bldwht}%5d${bldred} commands failed\n"  $commands_failed
  echo
  [[ $status -eq 0 && $runners_completed -gt 0 ]] && finish
  [[ $runners_started -eq 0 ]] && {
    printf "${bldylw}\nNo runners were specified.${txtrst}\nPlease run $0 -h for help.\n"
    finish
  }
  [[ $status -ne 0 ]] && abort $status
  finish
}

#______________________________________________________________________________
#
export args=$*

main args

# EOF
