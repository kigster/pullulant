#!/usr/bin/env bash
#_______________________________________________________________________________
#
# © 2016 Konstantin Gredeskoul
# Project Pullulant™
# https://github.com/kigster/pullulant/
#
# Distributed under MIT License
#_______________________________________________________________________________
#

function setup {
  export original_dir=$(pwd)
  export pu_home="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
  cd ${pu_home}
  source "lib/pu-loader"
}


function help-command() {
  pu-welcome-screen-short
  pu-print-help
}

setup
opts_features=""

[[ -z "$*" ]] && {
  pu-short-usage
  pu-short-help
  abort 0
}

while getopts "r:Rf:BCDEFHIKLNPRSTUZe:mkdhilnopqtvyx" opt; do
  case $opt in
    k)
      export opts_nokogiri_donot_use_system_libraries=yes
      ;;
    m)
      export opts_install_only_selected_themes=yes
      ;;
    N)
      export opts_interactive=yes           ;;
    e)
      eval "$OPTARG"
      exit 0                                ;;
    R)
      export runners=${installers}  ;;
    F)
      export opts_features=$(pu-features)   ;;
    r)
      if [[ "$(pu-is-valid-runner $OPTARG)" == "false" ]]; then
        printf "${bldred}$OPTARG is an invalid runner or helper :( ${txtrst}\n" >&2
        printf "Run with -l flag to see available runners/helpers, or -h for help\n" >&2
        abort 1
      fi

      [[ "${OPTARG}" == "sudo-enable"  ]] && export skip_sudo_disable=true
      [[ "${OPTARG}" == "sudo-disable" ]] && export sudoers_enabled=true
      if [ "${#runners}" -eq 0 ]; then
        runners="$OPTARG"
      else
        runners+=" $OPTARG"
      fi                                    ;;
    l)
      pu-short-header
      pu-installers-helpers
      finish
      ;;
    #========================= Features     =========================
    f)
      export opts_features+=" $OPTARG "     ;;
    t)
      pu-short-header
      pu-list-features
      finish                               ;;
    #========================= Runner Stuff =========================

    S)
      export opts_skip_sprout_wrap=yes      ;;
    B)
      export opts_skip_brew_upgrade=yes     ;;
    o)
      export opts_force=" --force "         ;;
    I)
      export opts_continue_on_runner_error=yes       ;;
    i)
      export opts_continue_on_statement_error=yes    ;;
    P)
      export opts_rsync_backup=             ;;

    #========================= Home Brew ============================

    U)
      export opts_brew_formulae_only=yes    ;;
    C)
      export opts_brew_casks_only=yes       ;;
    L)
      export opts_brew_link_only=yes        ;;
    y)
      export opts_brew_reinstall=yes        ;;
    K)
      export opts_brew_link_force=yes       ;;

    #========================= Other          =======================

    Z)
      export opts_change_shell_to_zsh=yes     ;;

    #========================= Output Control =======================
    p)
      export opts_suppress_headers=yes      ;;
    q)
      export opts_quiet=yes                 ;;
    n)
      export opts_dryrun=yes                ;;
    v)
      export opts_verbose=" -v ";           ;;

    #========================= Help and Info ========================
    E)
      pu-help-examples
      exit 0
      ;;
    D)
      pu-debug-help
      exit 0
      ;;
    d)
      opts_debug=yes
      ;;
    x)
      $0 -h | iconv -c -t ascii | sed "s,\x1B\[[0-9;]*[a-zA-Z],,g" > $pu_home/doc/help
      cat $pu_home/doc/help
      echo
      finish;                 ;;
    h)
      printf "$(help-command && pu-help-examples && pu-debug-help)" | less -R
      exit 0
      ;;
    H)
      help-command
      pu-help-examples
      pu-debug-help
      exit 0
      ;;
    \?)
      pu-short-usage
      echo
      printf "${bldred}ERROR: $* is an invalid option :( ${txtrst}\n" >&2
      echo
      abort 126
      ;;
    :)
      pu-short-usage
      echo
      printf "${bldred}ERROR: option -$opt requires an argument ${txtrst}\n" >&2
      echo
      abort 127
      ;;
  esac
done

function run_runners() {
  while (( "$#" )); do
    runner=$1
    # my arrays start with a 1
    runners_started=$((runners_started + 1))

    #[[ $runners_started -eq 1 ]] && pu-short-header

    # I so much rather prefer dashes in the function and file names than underscores.
    # Dashes just feel like a continuation. Underscores are from another era. Jurassic.
    printf "${txtrst}"
    pu-print-section-header "${bldwht}${bakblu}" ${runner}

    export runner_status=0
    eval ${runner}
    runner_status=${runner_status:-1}

    if [ ${runner_status} -ne 0 ]; then
      pu-underline-header "Runner ${bldred}${runner}${bldwht} messed up with an exit code [${bakred}${runner_status}${txtrst}]"
      echo

      [[ "${opts_continue_on_runner_error}" == "yes" ]] || gracefull_exit_with_summary

      pu-print-section-header "${txtblk}${bakylw}" "WARNING: continuing to the next runner, despite error, due to the -I flag."
      runners_ignored=$((runners_ignored + 1))
    else
      runners_completed=$(($runners_completed + 1))
    fi
    shift
    declare -a runners_list=($@)
    export runners_left=${#runners_list}

    if [[ -n "${opts_debug}" ]]; then
      echo
      if [[ "${#runners_list[@]}" -gt 0 ]]; then
        pu-list-components "Runners Left" "pur" "${runners_list[@]}"
      fi
    fi
  done
}

function pu-pluralize() {
  word=$1
  count=$2
  [[ -z "${count}" || -z "${word}" ]] && return

  pluralized=${word}
  [[ $count -gt 1 ]] && pluralized="${word}s"
  printf "$pluralized"
}

function gracefull_exit_with_summary() {

    printf "\n${txtrst}"

    pu-box-top
    pu-box-header " ${bldwht}SUMMARY/STATISTICS OF THIS RUN:${txtrst}"
    pu-box-separator
    pu-box-header $(printf "${bldwht}%4d${bldgrn} $(pu-pluralize 'runner' $runners_completed) succeeded${txtrst}"               $runners_completed)
    pu-box-header $(printf "${bldwht}%4d${bldylw} $(pu-pluralize 'runner' $runners_ignored) failed, but were ignored${txtrst}"  $runners_ignored)
    pu-box-header $(printf "${bldwht}%4d${bldylw} $(pu-pluralize 'runner' $runners_left) left, but were not started${txtrst}"   $runners_left)
    pu-box-separator
    pu-box-header $(printf "${bldwht}%4d${bldgrn} $(pu-pluralize 'command' $commands_completed) ran successfully${txtrst}"      $commands_completed)
    pu-box-header $(printf "${bldwht}%4d${bldylw} $(pu-pluralize 'command' $commands_ignored) had non-zero exit status, but were ignored${txtrst}" $runners_ignored)
    pu-box-header $(printf "${bldwht}%4d${bldred} $(pu-pluralize 'command' $commands_failed) failed${txtrst}"                   $commands_failed)
    pu-box-bottom
    echo
    [[ $runner_status -eq 0 && $runners_completed -gt 0 ]] && finish
    [[ $runners_started -eq 0 ]] && {
      printf "${bldylw}\nNo runners were specified.${txtrst}\nPlease run $0 -h for help.\n"
      finish
    }
    printf "${txtrst}"
    [[ $runner_status -ne 0 && -z "${opts_continue_on_runner_error}" ]] && abort $last_command_status
    finish
}

function main {
  pu-long-header
  pu-print-options
  package-config
  # loop over installers, and if either passed as an argument or no arguments
  #" at all – run it."

  # By now we should have $runners set to either the whole set of installers
  # or to something specific passed via the flag. It should not be blank.
  [[ -z "${runners}" ]] || on_start

  export runners_started=0
  export runners_ignored=0
  export runners_completed=0
  export runners_aborted=0

  export commands_failed=0
  export commands_completed=0
  export commands_ignored=0

  declare -a runners_list=($runners)
  export runners_total=${#runners_list[@]}
  export runners_left=$runners_total

  continue_next_runner
  gracefull_exit_with_summary
}

#______________________________________________________________________________
#
export args=$*

pu-trap-signals() {
  func="$1" ; shift
  for sig ; do
    trap "$func $sig" "$sig"
  done
}

function pu-interrupt() {
  printf "\n\n${txtrst}   ➜    Interrupting, since you pressed ${bakred}  Ctrl-C  ${txtrst}... Oh well :) \n"
  runner_status=130
  last_command_status=130
  gracefull_exit_with_summary
}

function continue_next_runner() {
  run_runners "${runners_list[@]}"
}

pu-trap-signals pu-interrupt INT TERM
pu-trap-signals continue_next_runner USR1


printf ${txtrst}

main args

# EOF
