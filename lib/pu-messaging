#!/usr/bin/env bash
#_______________________________________________________________________________
#
# © 2016 Konstantin Gredeskoul
# Project Pullulant™
# https://github.com/kigster/pullulant/
#
# Distributed under MIT License
#_______________________________________________________________________________
#
source "${bash_files_dir}/.bash_colors"

function pu-screen-width {
  stty -a | grep columns | awk '{print $6}'
}

function pu-width {
  echo -n "80"
}

function pu-repeat-char {
  local char=${1:0:1}
  char=${char:- }
  local width=${2:-$(pu-width)}
  for i in {0..1000}; do
    [[ $i -ge ${width} ]] && break
    printf "$char"
  done
}

function pu-line {
  pu-repeat-char "─"
}

# set background color to something before calling this
function pu-bar {
  pu-repeat-char " "
  printf "${txtrst}\n"
}

function pu-clean {
  local text="$*"
  printf "$text" | sed -r 's/\x1b\[[0-9;]*m?//g'
}

function pu-box-separator {
  printf "├"
  pu-line
  printf "┤\n"
}
function pu-box-top {
  printf "┌"
  pu-line
  printf "┐\n"
}
function pu-box-bottom {
  printf "└"
  pu-line
  printf "┘\n"
}
function pu-box-header {
  local text="$*"
  local width=$(pu-width)
  local uncolored_text=$(pu-clean "$text")
  local remaining_space_len=$(($width - ${#uncolored_text} - 2))
  printf "│ ${text}${txtrst} "
  pu-repeat-char " " $remaining_space_len
  printf "│\n"
}

function pu-underline-header {
  local title="$*"
  local width=80
  printf "${undylw}%s" "$title"
  local remaining=$(($width - ${#title}))
  printf "%*s${txtrst}\n" $remaining " "
}

function pu-indent-list {
  local list="$1"
  local width="$2"
  local indent="$3"
  echo "$list" | fold -sw $width | sed -E "s/ /, /g; s/(^|$)/${indent}/g; "
}

function pu-git-revision {
  git log --pretty=oneline --abbrev-commit | head -1 | awk '{print $1}'
}

function pu-long-header {
  pu-box-top
  pu-box-header "${bldgrn}Pullulant™ ${bldred}✩${txtrst} (or gently: 'pu')"
  pu-box-separator
  pu-box-header "${txtgrn}OS-X Development Environment Installer ${bldylw}(Version $(cat VERSION)) ${txtpur}Git Rev: $(pu-git-revision)"
  pu-box-header "${txtgrn}Inspired by the SproutWrap project from Pivotal Labs"
  pu-box-separator
  pu-box-header "${bldpur}(c) 2015-2016 Konstantin Gredeskoul, ${txtpur}«http://kig.re» «github.com/kigster»"
  pu-box-header "MIT License. ${txtred}This software is provided with no warranty implied or explicit."
  pu-box-bottom

  pu-installers-helpers
}

function pu-short-header {
  printf "${txtrst}"
  pu-box-top
  pu-box-header "${bldgrn}Pullulant™ ${bldred} ✩ ${txtrst} (or gently: 'pu')                             ${txtblk}${bakpur} Version ${bakblu} $(cat VERSION) ${bakpur}"
  pu-box-bottom
}

function pu-print-options {
  printf "  Enabled Options:${bldylw}\n"
  count=0
  for option in ${pu_options}; do
    option_value=$(pu_option_value $option)
    if [ -z "${option_value/ /}" ]; then
      continue
    else
      [[ $count -gt 0 ]] && printf ", "
      if [ "$option_value" == "yes" ]; then
        printf "${bldgrn}%s" ${option/opts_/}
      else
        printf "${bldgrn}%s=${bldylw}%s" ${option/opts_/} ${option_value}
      fi
    fi
    count=$(($count + 1))
  done
  printf "\n"
}

function pu-installers-helpers {
  local installer_list=$(pu-indent-list "$installers" 65 "   ")
  local helper_list=$(pu-indent-list    "$helpers"    65 "   ")

  printf "                                                                                    \n"
  printf "${txtrst}Installers:\n"
  printf "${txtylw}%-68s \n" "$installer_list"
  printf "                                                                                    \n"
  printf "${txtrst}Helpers:\n"
  printf "${txtylw}%-68s \n" "$helper_list"
  printf "                                                                                    \n"

  pu-list-current-runners
}

function pu-list-current-runners {
  linebreak="\n"
  local run_list=$(pu-indent-list "$runners"    80 '   ')
  if [ ! -z "$(echo $run_list | sed 's/[ \n]//g')" ]; then
    printf "${bldwht}${undylw}                                                                                    \n\n"
    printf "${txtrst}Current Run List:\n"
    printf "${txtylw}%-68s ${txtrst}\n" "$run_list"
  fi
  printf "${bakgrn}"
  pu-bar
}

function pu-list-features {
  source "lib/pu-features"

  linebreak="\n"
  local run_list=$(pu-indent-list "$(pu-features)"    80 '   ')
  if [ ! -z "$(echo $run_list | sed 's/[ \n]//g')" ]; then
    printf "${bldwht}${undylw}                                                                                    \n\n"
    printf "${txtrst}Current Feature List:\n"
    printf "${txtylw}%-68s ${txtrst}\n" "$run_list"
  fi
  printf "${bakgrn}"
  pu-bar
}

function pu-welcome-screen-short {
  pu-long-header
  printf "\n${txtrst}"
}


function pu-print-section-header {
  [[ -n "${opts_suppress_headers}" ]] && return
  pu-box-top
  pu-box-header "${bldwht}${bakblu} $*"
  pu-box-bottom
}

function pu-print-help {
  # ar:SBLRKFCfqnvlhHxp
  printf "USAGE SUMMARY:\n\n"
  printf "  $(basename $0) -a          [features] [-S] [-B] [-Z] [-iI] [fmt]\n"
  printf "  $(basename $0) [runners]   [features] [-S] [-B]            [fmt]\n"
  printf "  $(basename $0) -r homebrew [features] [-L|-F|-C] [-R] [-f] [-K] [fmt]\n"
  printf "\nOr for Help:\n"
  printf "  $(basename $0) [-l|-T|-h|-H|-x]\n"
  printf "
$(pu-underline-header 'Where: ')

  [runners]   is one or more installers or helpers passed via '-r' flag, like
              so: ' ... -r install_bash -r bash_it -r osx ...'
              Print the available list by running '$(basename $0) -l'

  [fmt]       is combination of flags controlling the output you see on the
              screen: [-n] [-q|-v] [-p]

  [features]  is a list of enabled features (see below).

$(pu-underline-header "Full Run (All installers):")

  -a          run [a]ll installers in their order (from the 'installers' dir)
    -S        [S]proutwrap is disabled during the install
    -B        [B]rew-upgrade is disabled
    -P        No backu[P] for rsync of bash and zsh files (default is to backup)

$(pu-underline-header 'Error Handing:')

              Default error handling is pessimistic: installer stops upon any
              error code returned from a single 'run' statement.

              You can control error handling at two levels:

  -i          [i]gnore errors and continue to the next 'run' statement.

  -I          Stops running the current installer that produced an error, skips
              the rest of it, and continues to the next installer. For example,
              in this mode, if one homebrew package fails to install, the rest
              of homebrew installer will be skipped, and the next installer in
              the run list will begin.

$(pu-underline-header 'Features:')

  -t feature1 -t feature2 ...

              List of features to run in addition to the 'default'. Features add
              a number of brew packages, nodejs modules, bash-it plugins and
              aliases grouped together for a specific purpose. For example, 'ruby'
              feature installs RubyMine IDE, and other ruby-specific tools, while
              'python' feature installs PyCharm IDE and python-specific tools.

              Take a look at the 'features' folder for more information. Note
              that the 'default' feature always runs, and contains the definition
              of the variables other features can extend.

              Available Features: ${bldgrn}$(echo $(pu-features))${txtrst}

  -T          List available fea[T]ures in the 'features' folder.

$(pu-underline-header 'Partial Run')

              Multiple runners can be listed in quotes or multiple -r flags:
  -r runner   run only a specified [r]unner (helper or installer)
              eg: $(basename $0) -r 'zsh osx' -r home

  -f          [F]orce – applies to some installers, ie. brew (--force) and
              zsh (overwrites current)

$(pu-underline-header 'Homebrew:')

              -C -F -L flags allow picking specific subset of the install.
              The flags can mix. Adding all three is the same as adding none.

  -L          Only [L]ink packages configured for brew linking
  -C          Only [C]asks are installed from a configured list
  -F          Only [F]ormulas are installed from a configured list

              These apply to all brew commands:
  -R          [R]einstall each formulae during brew install
  -K          Relin[K] all brew formulas/casks during install

$(pu-underline-header 'Zsh')

  -Z          Change the default shell to ZSH and install 'oh-my-zsh'

$(pu-underline-header 'Output control:')

  -p          su[p]press pretty section headers for more compact output
  -q          [q]uiet mode: stop printing commands before and after run.
  -v          [v]erbose - show each command's output, and add -v to some
  -n          dry-ru[n] – print commands, but don't actually run them.

$(pu-underline-header 'Help & Info:')

  -l          [l]ist available runners – helpers and installers
  -h          paginated [h]elp message in full color
  -H          non-paginated [H]elp message in full color
  -x          non-paginated help message with NO color, plain ASCII

$(pu-underline-header 'Examples:')

    # install everything with the default (small) set of packages:
    ${bldgrn}$(basename $0) -a${txtrst}

    # install everything with additional packages and plugins enabled
    # suitable for ruby,python,node development, as well as install
    # services used in web development such as nginx, haproxy, etc, as well
    # as install the packages and plugins for managing AWS infrastructure.
    ${bldgrn}$(basename $0) -a -t 'ruby python nodejs web aws docker'${txtrst}

    # use a helper (not an installer) to wipe clean and reinstall postgresql
    # from brew, create a new UTF8 database, and ensure it's running after.
    ${bldgrn}$(basename $0) -r reinstall-postgres${txtrst}

    # wipe and reinstall homebrew, with additional ruby packages included
    ${bldgrn}$(basename $0) -r brew-wipe   -r homebrew -t ruby${txtrst}

    # repair and install all brew packages, with additional python packages
    ${bldgrn}$(basename $0) -r brew-repair -r homebrew -t python${txtrst}

    # when installing brew packages, skip casks or linking, and only install
    # formulas. Use verbose output.
    ${bldgrn}$(basename $0) -r homebrew -F -pv${txtrst}

    # install everything, minus homebrew and sprout-wrap, including
    # features listed. Note that brew-specific portion of features
    # is ignored in this case.
    ${bldgrn}$(basename $0) -aSB -t ruby -t python -t nodejs -t web -t aws${txtrst}
"
}

function pu-print-detailed-usage {
  printf "
$(pu-underline-header "Runner")

    Most common usage is with the ${bldlw}-a ${txtrst} flag, that runs all installers.
    Installers are bash modules located in the ${modules_dir} folder. Each
    installer has a bash function that matches the name of the file.

    The -r flag can be supplied more than once, or once but with multiple
    arguments in quotes, eg ${bldylw}-r 'runner1 runner2'${txtrst} or ${bldylw}-r runner1
    -r runner2${txtrst}. Presence of this flag indicates that only specified
    runnings will run.

$(pu-underline-header "Helpers")
    Helpers are similar to installers, but they are not ordered, and are
    not included in the default install. They are meant to be used for ad-hoc
    installations, fixes, uninstalls, etc.

    For example, to enable password-less sudo for your current account (not
    recommended!), use 'sudo-enable' helper:

    $(basename $0) -r sudo-enable

$(pu-underline-header "Customizing")
    You can add new installers and helpers by adding new files in the
    corresponding folders with bash functions matching the file name.


"
}
