#!/usr/bin/env bash
#_______________________________________________________________________________
#
# (c) 2016 Konstantin Gredeskoul
# https://github.com/kigster
#
# For project Pullulant
# https://github.com/kigster/pullulant/
#
# MIT License
#_______________________________________________________________________________
# encoding: UTF-8

trap EventHandler.onCtrlC INT

function EventHandler.onCtrlC {
  printf "\n\n\n${bakred}${bldwht}   CTRL-C: Aborting installer.    ${txtrst}\n"
  Application.finish
}
function EventHandler.onStart {
  run "sudo rm -f ${const_cmd_stdout} ${const_cmd_stderr} # hide-command"
  [[ "$sudoers_enabled" ]] && pu-print-section-header "sudo-enable" && sudo-enable
}

function EventHandler.onExit {
  [[ "$sudoers_enabled" ]] && sudo-disable
  run "rm -rf ${const_cmd_stderr} # hide-command"
  run "rm -rf ${const_cmd_stdout} # hide-command"

  [[ -n "${exit_status}" ]] && exit_status=${status-0}

  Application.printSummary
  # Application.printExitStatus $exit_status
  echo ${exit_status}
}

function Application.main {
  Application.begin

  # loop over installers, and if either passed as an argument or no arguments
  #" at all – run it."
  for local_runner in ${Application__runners}; do
    Application.executeRunner $local_runner
  done

  Application.finish
}

function Application.begin {
  # By now we should have ${Application__runners} set to either the whole set of installers
  # or to something specific passed via the flag. It should not be blank.
  [[ -z "${Application__runners}" ]] || EventHandler.onStart

  export ${Application__runners_started}=0
  export ${Application__runners_ignored}=0
  export ${Application__runners_completed}=0

  export commands_failed=0
  export commands_completed=0
  export commands_ignored=0
}

function Application.finish {
  Application.exit
}

function Application.abort {
  status=$1
  Application.exit
}

function Application.exit() {
  cd ${original_dir}
  local __status=$(EventHandler.onExit)
  exit $(($__status+0))
}

function Application.printExitStatus() {
  exit_status=${1-${status}}
  if [ $exit_status -eq 0 ]; then
    printf "${txtblk}"
    sep "\n\n"
    printf "\n 😃   ${bldgrn}Everything is awesome.${txtblk} \n"
    sep
    printf "\n${txtrst}"
  else
    printf "${txtblk}"
    sep "\n\n"
    printf "\n ⛔️    ${bldred}Too bad :( ${txtblk}\n"
    sep
    printf "\n${txtrst}"
    end
  fi
}

function Application.printSummary {
  printf "\n"
  [[ ${${Application__runners_completed}} -gt 0 ]]  && printf "${bldwht}%5d${bldgrn} runners succeeded\n" ${Application__runners_completed}
  [[ ${${Application__runners_ignored}} -gt 0 ]]    && printf "${bldwht}%5d${bldylw} runners failed, but were ignored\n"  $Application__${Application__runners_ignored}
  sep
  [[ ${commands_completed} -gt 0 ]] && printf "${bldwht}%5d${bldgrn} commands ran successfully\n" $commands_completed
  [[ ${commands_ignored} -gt 0 ]]   && printf "${bldwht}%5d${bldylw} commands had non-zero exit status, but were ignored\n" $Application__${Application__runners_ignored}
  [[ ${commands_failed} -gt 0 ]]    && printf "${bldwht}%5d${bldred} commands failed\n"  $commands_failed
  echo
  [[ $status -eq 0 && ${Application__runners_completed} -gt 0 ]] && Application.finish
  [[ ${Application__runners_started} -eq 0 ]] && {
    printf "${bldylw}\nNo runners were specified.${txtrst}\nPlease run $0 -h for help.\n"
  }
}

function Application.executeRunner {
  runner=${1}

  # my arrays start with a 1
  export ${Application__runners_started}=$((${Application__runners_started} + 1))

  [[ ${Application__runners_started} -eq 1 ]] && pu-short-header

  # I so much rather prefer dashes in the function and file names than underscores.
  # Dashes just feel like a continuation. Underscores are from another era. Jurassic.
  pu-print-section-header ${runner}

  export status=
  eval ${runner}
  export status=${status:-1}

  if [ ${status:-1} -ne 0 ]; then
    printf "${bldred}Non-zero status ${status} from '${runner}' runner :( ...\n${txtrst}"
    [[ -z "${opts_ignore_errors}" ]] && Application.abort $status
    export ${Application__runners_ignored}=$((${Application__runners_ignored} + 1))
  fi

  export ${Application__runners_completed}=$((${Application__runners_completed} + 1))
}

function run {
  cmd=$1
  ignore_error=${2-""}
  status=0
  if [ ! -z "${opts_dryrun}" ]; then
    printf "[opts_dryrun]  ${txtgrn}${cmd}${txtrst}\n"
  else
    check_exit "$cmd" $ignore_error
  fi
  return $status
}

function check_exit {
  local cmd=$1
  local ignore_error=${2-""}
  local cmd_prints=  # 'yes' if the command actually meant to output something, null otherwise
  local cmd_verbose= # 'yes' if the verbose flag is passed, or "#show-stdout" comment included
  local cmd_quiet=   # 'yes' if globally quiet, or command passed #hide-command command
  local out=

  out=$(echo "$cmd" | egrep -c 'echo|printf')
  [[ $? -eq 0 ]]             && cmd_prints=yes

  out=$(echo "$cmd" | egrep -c 'hide-command')
  [[ $? -eq 0 ]]             && cmd_quiet=yes
  [[ -n "${opts_quiet}" ]]   && cmd_quiet=yes

  out=$(echo "$cmd" | egrep -c 'show-stdout')
  [[ $? -eq 0 ]]             && cmd_verbose=yes
  [[ -n "${opts_verbose}" ]] && cmd_verbose=yes

  # print the user-visible info about the command, if any
  if [ -z "${cmd_prints}" -a -z "${cmd_quiet}" ]; then
    if [ -z "${cmd_verbose}" ]; then
      printf "${bldpur}%-80.80s ${bldylw}→" "$cmd" | tee -a ${const_cmd_stdout}
    else
      printf "${bldpur}%s${txtrst}\n" "$cmd" | tee -a ${const_cmd_stdout}
    fi
  fi

  # print the actual STDOUT if present, or nothing when captured
  printf "${txtblu}"

  if [ -n "${cmd_prints}" ]; then
    eval "$cmd 2>${const_cmd_stderr}"
  elif [ -n "${cmd_verbose}" -a -z "${cmd_quiet}" ]; then
    eval "$cmd 2>${const_cmd_stderr}"
  else
    eval "$cmd 2>${const_cmd_stderr} 1>${const_cmd_stdout}"
  fi

  real_status=$?
  status=${real_status}

  if [ -n "${ignore_error}" -a $status -ne 0 ]; then
    status=0
    commands_ignored=$(($commands_ignored + 1))
  else
    [[ $status -eq 0 ]] && commands_completed=$(($commands_completed + 1))
    [[ $status -ne 0 ]] && commands_failed=$(($commands_failed + 1))
  fi

  if [ -n "${cmd_prints}" ]; then
    return $status
  fi

  if [ "$status" -eq 0 ]; then
    if [ -z "${cmd_quiet}" ]; then
      if [ -z "${cmd_verbose}" ]; then
        if [ $real_status -ne 0 ]; then
          printf "${var_pullulant_symbol_ignored}${txtrst}\n"
        else
          printf "${var_pullulant_symbol_ok}${txtrst}\n"
        fi
      fi
    fi
  else # error – print a little icon
    [[ -z "${cmd_verbose}" ]] && printf "${bldred}${var_pullulant_symbol_error}${txtrst}\n"

    if [ -n "${opts_ignore_errors}" ]; then
      cat ${const_cmd_stderr} >> ${const_combined_stderr}
      status=0
    else
      [[ -s "${const_cmd_stderr}" ]]  && printf "\n${bldred}$(cat ${const_cmd_stderr})${txtrst}\n"
      printf "\n"
      printf "${txtrst}  Command: ${bldred}${cmd}\n"
      printf "${txtrst}Exit code: ${bldred}$status\n"
      printf "${txtrst}   Result: ${bldred}${runner}${txtrst} runner must Application.abort.\n\n"
    fi
  fi
  return $status
}
