#!/usr/bin/env bash


##-----------------------------------------------------------------------------
##    function: mem [egrep pattern] [ -U user[,..] | -g group[,..]
##                                                 | -p pid[,...] ]
##          eg: mem Chrome
##                      5116 Mb   RSS
##                    165788 Mb   VSZ
##              # addup all ruby processes for user saves
##          eg: mem ruby -U saves
##
## description:
##              mem helper uses system 'ps' command to add up the memory (in Mb)
##              for either all processes (the default) or the processes that
##              match an optional pattern (first argument), among either all
##              processes (default), or narrowed down by one or more flags
##              that sysmte 'ps' command understands, such as '-U user'.
##              Note: any number of arguments for 'ps' are allowed.
##
mem() {
  local pattern=
  if [[ ${1:0:1} != '-' ]]; then
    pattern=$1
    shift
  fi
  local scope='-e'
  [[ -n ${1} && ${1:0:1} == '-' ]] && {
    scope=$*
  }
  local filter=
  if [[ -n ${pattern} ]] ; then
    ps -orss,vsz,args ${scope} | egrep "RSS|${pattern}" | grep -v grep | addup --units Mb -n 1024 1 2
  else
    ps -orss,vsz,args ${scope} | grep -v grep | addup --units Mb -n 1024 1 2
  fi
}

#..................................................................................
#
#    function: <command> | addup [--units 'name' ] [-n | -d value] column_number, ...
#          eg: ps -e -orss,vsz,args $* | addup --units Mb -n 1024 1 2
#         see: mem
#        note: try 'addup --help
#
# description:
#              Lower level command that is meant to be used by higher abstractions.
#              Adds up values in columns, optionally displaying the headers.
#
#              This function will sum up any specified columns from the multi-column
#              STDIN, and can divide or multiply the result by an optional coefficient.
#              Specify units with -u, eg. "Mb" or "Gb", etc.
#
#     depends: requires the supporting AWK script "~/.addup.awk" to be installed.
#
addup() {
  local addup_debug=0
  while :; do
    case $1 in
      -h|-\?|--help)
          shift
          local addup__help=1
          ;;
      -d|--debug)
          shift
          addup__debug=1
          ;;
      -u|--units)
          shift
          if [[ -n "$1" ]]; then
              local addup__units=$1
              shift
          else
              printf 'ERROR: "--units" requires a non-empty option argument.\n' >&2
              return 1
          fi
          ;;

      -n|--denominator)
          shift
          if [ -n "$1" ]; then
              local addup__denominator=$1
              shift
          else
              printf 'ERROR: "--denominator" requires a non-empty option argument.\n' >&2
              exit 1
          fi
          ;;

      -m|--multiplier)
          shift
          if [ -n "$1" ]; then
              local addup__multiplier=$1
              shift
          else
              printf 'ERROR: "--multiplier" requires a non-empty option argument.\n' >&2
              exit 1
          fi
          ;;
      --)              # End of all options.
          shift
          break
          ;;
      -?*)
          printf 'WARN: Unknown option (ignored): %s\n' "$1" >&2
          exit 127
          shift
          ;;
      *)  # Default case: If no more options then break out of the loop.
          break
          shift
    esac
  done

  [[ -n $addup_help ]] && {
    printf "${bldylw}usage:   ${bldgrn}addup [ options ] col1 col2 ....${txtrst}\n"
    printf "${bldylw}options:${txtrst} \n"
    printf "    -h/--help                   print help\n"
    printf "    -d/--debug                  print debugging info in awk\n"
    printf "    -u/--units             str  set units to display next to the numbers\n"
    printf "    -m/--multiplier          M  specifies multiplier coefficient for each column's sum\n"
    printf "    -n/--denominator         N  specifies denominator for each addup__cols's sum\n"
    echo
    printf "${bldylw}example:${txtrst} \n"
    printf "    ps -orss,vsz,args | addup --units Gb -n \$((1024*1024)) 1 2\n\n"
    return
  }

  local addup__cols=$@

  [[ -n ${DEBUG} ]] && printf "addup__cols argument: ${addup__cols[*]}\n"

  for col in ${addup__cols[@]}; do
    [[ $col =~ ^[0-9]+$ ]] || {
      printf "usage: ${bldgrn}some command | ${bldblu}addup ${bldylw}<column number> [, <column number>, ... ]${txtrst}\n"
      printf "   eg: ps -orss,vsz,args | grep ruby | addup -u Mb -m 1024 1 2\n"
      exit
    }
  done

  awk -v columns="${addup__cols[*]}" \
      -v denominator="${addup__denominator}" \
      -v multiplier="${addup__multiplier}" \
      -v units="${addup__units}" \
      -v debug="${addup__debug}" \
      -f ~/.pu_addup.awk <&0
}


pu::convert() {
  local from_ext=$1
  shift
  local to_ext=$1
  shift
  if [[ "$*" =~ "--" ]]; then
    printf "${bldred}Whoops!${txtrst} Did you specify arguments to convert via --option? \n"
    printf "All arguments to convert ${bldblu}must have a single dash!.${txtrst}\n"
    return
  fi

  if [[ -z "${from_ext}" || -z ""${to_ext}"" ]]; then
    printf "usage: ${bldgrn}pu::img::convert from-extension to-extension [options-to-convert]${txtrst}\n"
    printf "       Works only in the current directory, and is non-recursive, case-sensitive.\n\n"
    printf "   eg: ${bldblu}img::convert png jpg --quality 100${txtrst}\n"
    return
  fi

  for f in $(find . -type f -name "*.${from_ext}" -depth 1 -print); do
    local to_file=$(printf "${f}" | sed -E "s/(.*)\.${from_ext}/\1.${to_ext}/g")
    [[ -z ${to_file} ]] && {
      echo "to_file is nil, can not convert from $f"
      return
    }
    [[ -z ${f} ]] && {
      echo "file is nil, can not convert"
      return
    }
    if [[ -s ${to_file} ]]; then
      printf "${bldylw}Found existing file ${to_file}, aborting.\n"
      return
    fi
    convert $* $f $to_file
    result=$?
    if [[ $result != 0 ]]; then
      printf "${bldred}convert exited with status $result, aborting...${txtrst}\n"
      return
    fi

    fsize=$(pu::fsize $f)
    tsize=$(pu::fsize $to_file)
    ratio=$(ruby -e "printf '%7.2f', 100.0 * ${tsize} / ${fsize}")
    if [[ $fsize -gt $tsize ]]; then
      action=" decrease"
    elif [[ $fsize -lt $tsize ]]; then
      action=" increase"
    else
      action="no change"
    fi
    printf "${bldylw} [size $ratio%% ${action}] converted ${bldblu}$f ${bldgrn}$to_file ${bldpur}$*  ${txtrst}\n"
  done
}

file.size() {
  ls -al $* | awk '{print $5}'
}

jpg.bmp() {
  dir=
  if [ ! -z "$1" ]; then
    dir="$1/"
  fi
  for file in `ls -1 *.JPG *.jpg`; do
    echo converting $file...
    name=$(openssl rand -hex 4 | tr 'a-z' 'A-Z')
    convert $file ${dir}${name}.BMP
  done
}

function hashbmp {
  for file in `ls -1 *.bmp *.BMP`; do
    echo converting $file...
    name="$( md5 -q $file | cut -c 1-8).bmp"
    mv $file $name
  done
}

function console {
  modem=`ls -1 /dev/cu.* | grep -vi bluetooth | tail -1`
  baud=${1:-9600}
  if [ ! -z "$modem" ]; then
    minicom -D $modem  -b $baud
  else
    echo "No USB modem device found in /dev"
  fi
}

# Choose the best editor to open a MarkDown file (or any other text file)
# Override array $mkd_editors[@] if your priority list is different
md.edit() {
  [[ -n "${mkd_editors}" ]] || declare -a mkd_editors=("byword" "mate" "atom" "vim")
  for editor in "${mkd_editors[@]}"; do
    if [[ -n "$(type $editor | grep function)" || -n "$(which $editor)" ]]; then
      $editor $*
      break
    fi
  done
}

byword() {
  [[ -n "${byword_app}" ]] || byword_app="/Applications/Byword.app"
  if [[ -d ${byword_app} ]]; then
    open $byword_app $*
  else
    [[ "$(which mate)" && $(mate "$*") ]] || vim "$*"
  fi
}

# similar to 'watch'
observe() {
  local refresh=1
  [[ "$1" =~ [0-9] ]] && refresh=$1 && shift
  cmd=$@
  while true; do
    printf "${bakblk}${bldblu}$(date) | ${bldwht}command: ${bldgrn}${cmd[@]}"
    printf "\033[K"
    printf "${txtrst}\n\n"
    time ${cmd[@]} sleep $refresh
    clear
  done
}


today() {
  date '+%Y-%m-%d'
}

now() {
  date '+%Y-%m-%d.%H:%M:%S'
}

# Replace a string in a provided file, eg:
# replf ~/.bashrc "s/\/Users\/kig/\/Users\/dev/s"
replf() {
  local file=$1
  local regex=$2
  sed -i -e "${regex}" $file
}

# Replace a text string in all files in the directory
# defaults to ".":
# eg. repld "s/\/Users\/kig/\/Users\/dev/s"
#
# but can be changed with the second argument.
# eg. repld "s/\/Users\/kig/\/Users\/dev/s" ~/
repld(){
  local regex=${1}
  local dir=${2:-"."}
  echo find ${dir} -type f -exec sed -i -e "'${regex}'" {} \; -print
  find ${dir} -type f -exec sed -i -e "${regex}" {} \; -print
}


[[ $(uname -s ) != 'Darwin' ]] && return

function see() {
  qlmanage -p $* 2>/dev/null
}

osx.hostname() {
  local host=$*
  [[ -z $host ]] && {
    echo "usage: osx.hostname desired-host-name"
    return
  }

  echo setting ComputerName to $host...
  sudo scutil --set ComputerName $host

  localhost=$(echo $host | sed -E 's/\..*$//g')

  echo setting LocalHostName to $localhost...
  sudo scutil --set LocalHostName ${localhost}

  echo setting HostName to $host...
  sudo scutil --set HostName $host
}


function csr.create() { 
  local name=$1
  if [[ -z $name ]] ; then
    echo 'usage: scr::create site.domain.com'
    exit 1
  fi

  openssl req -new -newkey rsa:2048 -nodes -keyout $name.key -out $name.csr
}


function rsync.incremental() {
  local from=$1
  shift
  local to=$1
  shift

  if [[ -z $from || -z $to ]] ; then
    echo "usage: ${bldylw}rsync.incremental <from> <to> [ rsync flags ]${clr}"
    echo "   eg: rsync.incremental /Volumes/Foo/ /Volumes/foo-new"
    return
  fi

  printf  "${bldblu}Starting rsync from ${bldylw}${from}${bldblu} to ${bldgrn}${to}${clr}...\n"

  rsync -aXh --stats --progress --update \
      --exclude='**/.Spotlight-*' \
      --exclude="**/.DS_Store" \
      --exclude="**/.Trashes" \
      --exclude="**/.TemporaryItems" \
      --exclude="**/.DocumentRevision*" \
      --ignore-errors $* $from $to
}

alias rsi='rsync.incremental'

