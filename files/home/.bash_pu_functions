#!/usr/bin/env bash

addup() {
  columns=$@

  [[ -n ${DEBUG} ]] && printf "columns argument: ${columns}\n"

  for col in ${columns[@]}; do
    [[ $col =~ ^[0-9]+$ ]] || {
      printf "usage: ${bldgrn}some command | ${bldblu}addup ${bldylw}<column number> [, <column number>, ... ]${txtrst}\n"
      printf "   eg: ps -orss,vsz,args | grep ruby | addup 1 2\n"
      exit
    }
  done

  awk -v columns="${columns[*]}" -f ~/.pu_addup.awk <&0
}


pu::convert() {
  local from_ext=$1
  shift
  local to_ext=$1
  shift
  if [[ "$*" =~ "--" ]]; then
    printf "${bldred}Whoops!${txtrst} Did you specify arguments to convert via --option? \n"
    printf "All arguments to convert ${bldblu}must have a single dash!.${txtrst}\n"
    return
  fi

  if [[ -z "${from_ext}" || -z ""${to_ext}"" ]]; then
    printf "usage: ${bldgrn}pu::img::convert from-extension to-extension [options-to-convert]${txtrst}\n"
    printf "       Works only in the current directory, and is non-recursive, case-sensitive.\n\n"
    printf "   eg: ${bldblu}img::convert png jpg --quality 100${txtrst}\n"
    return
  fi

  for f in $(find . -type f -name "*.${from_ext}" -depth 1 -print); do
    local to_file=$(printf "${f}" | sed -E "s/(.*)\.${from_ext}/\1.${to_ext}/g")
    [[ -z ${to_file} ]] && {
      echo "to_file is nil, can not convert from $f"
      return
    }
    [[ -z ${f} ]] && {
      echo "file is nil, can not convert"
      return
    }
    if [[ -s ${to_file} ]]; then
      printf "${bldylw}Found existing file ${to_file}, aborting.\n"
      return
    fi
    convert $* $f $to_file
    result=$?
    if [[ $result != 0 ]]; then
      printf "${bldred}convert exited with status $result, aborting...${txtrst}\n"
      return
    fi

    fsize=$(pu::fsize $f)
    tsize=$(pu::fsize $to_file)
    ratio=$(ruby -e "printf '%7.2f', 100.0 * ${tsize} / ${fsize}")
    if [[ $fsize -gt $tsize ]]; then
      action=" decrease"
    elif [[ $fsize -lt $tsize ]]; then
      action=" increase"
    else
      action="no change"
    fi
    printf "${bldylw} [size $ratio%% ${action}] converted ${bldblu}$f ${bldgrn}$to_file ${bldpur}$*  ${txtrst}\n"
  done
}

pu::fsize() {
  ls -al $1  | cut -d ' ' -f 8
}

function jpg2bmp {
  dir=
  if [ ! -z "$1" ]; then
    dir="$1/"
  fi
  for file in `ls -1 *.JPG *.jpg`; do
    echo converting $file...
    name=$(openssl rand -hex 4 | tr 'a-z' 'A-Z')
    convert $file ${dir}${name}.BMP
  done
}

function hashbmp {
  for file in `ls -1 *.bmp *.BMP`; do
    echo converting $file...
    name="$( md5 -q $file | cut -c 1-8).bmp"
    mv $file $name
  done
}

function console {
  modem=`ls -1 /dev/cu.* | grep -vi bluetooth | tail -1`
  baud=${1:-9600}
  if [ ! -z "$modem" ]; then
    minicom -D $modem  -b $baud
  else
    echo "No USB modem device found in /dev"
  fi
}

# Choose the best editor to open a MarkDown file (or any other text file)
# Override array $mkd_editors[@] if your priority list is different
function mkd() {
  [[ -n "${mkd_editors}" ]] || declare -a mkd_editors=("byword" "mate" "atom" "vim")
  for editor in "${mkd_editors[@]}"; do
    if [[ -n "$(type $editor | grep function)" || -n "$(which $editor)" ]]; then
      $editor $*
      break
    fi
  done
}

function byword() {
  [[ -n "${byword_app}" ]] || byword_app="/Applications/Byword.app"
  if [[ -d ${byword_app} ]]; then
    open $byword_app $*
  else
    [[ "$(which mate)" && $(mate "$*") ]] || vim "$*"
  fi
}

function watch() {
  local refresh=1
  [[ "$1" =~ [0-9] ]] && refresh=$1 && shift
  cmd=$@
  while true; do
    printf "${bakblk}${bldblu}$(date) | ${bldwht}command: ${bldgrn}${cmd[@]}"
    printf "\033[K"
    printf "${txtrst}\n\n"
    time ${cmd[@]}
    sleep $refresh
    clear
  done
}
